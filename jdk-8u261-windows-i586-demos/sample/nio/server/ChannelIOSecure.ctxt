#BlueJ class context
comment0.target=ChannelIOSecure
comment0.text=\r\n\ A\ helper\ class\ which\ performs\ I/O\ using\ the\ SSLEngine\ API.\r\n\ <P>\r\n\ Each\ connection\ has\ a\ SocketChannel\ and\ a\ SSLEngine\ that\ is\r\n\ used\ through\ the\ lifetime\ of\ the\ Channel.\ \ We\ allocate\ byte\ buffers\r\n\ for\ use\ as\ the\ outbound\ and\ inbound\ network\ buffers.\r\n\r\n\ <PRE>\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Application\ Data\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ src\ \ \ \ \ \ requestBB\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ \ ^\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v\ \ \ \ \ |\ \ \ \ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ +----+-----|-----+----+\r\n\ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ SSL|Engine\ \ \ \ |\r\n\ \ \ wrap()\ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ unwrap()\r\n\ \ \ \ \ \ \ \ \ \ \ |\ OUTBOUND\ |\ INBOUND\ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ \ \ \ \ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ +----+-----|-----+----+\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ ^\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \ \ \ |\ \ \ \ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ v\ \ \ \ \ \ \ \ \ \ \ |\r\n\ \ \ \ \ \ \ \ \ \ \ \ outNetBB\ \ \ \ \ inNetBB\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Net\ data\r\n\ </PRE>\r\n\r\n\ These\ buffers\ handle\ all\ of\ the\ intermediary\ data\ for\ the\ SSL\r\n\ connection.\ \ To\ make\ things\ easy,\ we'll\ require\ outNetBB\ be\r\n\ completely\ flushed\ before\ trying\ to\ wrap\ any\ more\ data,\ but\ we\r\n\ could\ certainly\ remove\ that\ restriction\ by\ using\ larger\ buffers.\r\n\ <P>\r\n\ There\ are\ many,\ many\ ways\ to\ handle\ compute\ and\ I/O\ strategies.\r\n\ What\ follows\ is\ a\ relatively\ simple\ one.\ \ The\ reader\ is\ encouraged\r\n\ to\ develop\ the\ strategy\ that\ best\ fits\ the\ application.\r\n\ <P>\r\n\ In\ most\ of\ the\ non-blocking\ operations\ in\ this\ class,\ we\ let\ the\r\n\ Selector\ tell\ us\ when\ we're\ ready\ to\ attempt\ an\ I/O\ operation\ (by\ the\r\n\ application\ repeatedly\ calling\ our\ methods).\ \ Another\ option\ would\ be\r\n\ to\ attempt\ the\ operation\ and\ return\ from\ the\ method\ when\ no\ forward\r\n\ progress\ can\ be\ made.\r\n\ <P>\r\n\ There's\ lots\ of\ room\ for\ enhancements\ and\ improvement\ in\ this\ example.\r\n\ <P>\r\n\ We're\ checking\ for\ SSL/TLS\ end-of-stream\ truncation\ attacks\ via\r\n\ sslEngine.closeInbound().\ \ When\ you\ reach\ the\ end\ of\ a\ input\ stream\r\n\ via\ a\ read()\ returning\ -1\ or\ an\ IOException,\ we\ call\r\n\ sslEngine.closeInbound()\ to\ signal\ to\ the\ sslEngine\ that\ no\ more\r\n\ input\ will\ be\ available.\ \ If\ the\ peer's\ close_notify\ message\ has\ not\r\n\ yet\ been\ received,\ this\ could\ indicate\ a\ trucation\ attack,\ in\ which\r\n\ an\ attacker\ is\ trying\ to\ prematurely\ close\ the\ connection.\ \ \ The\r\n\ closeInbound()\ will\ throw\ an\ exception\ if\ this\ condition\ were\r\n\ present.\r\n\r\n\ @author\ Brad\ R.\ Wetmore\r\n\ @author\ Mark\ Reinhold\r\n
comment1.params=sc\ blocking\ sslc
comment1.target=ChannelIOSecure(java.nio.channels.SocketChannel,\ boolean,\ javax.net.ssl.SSLContext)
comment1.text=\r\n\ Constructor\ for\ a\ secure\ ChannelIO\ variant.\r\n
comment10.params=src
comment10.target=int\ write(java.nio.ByteBuffer)
comment10.text=\r\n\ Try\ to\ write\ out\ as\ much\ as\ possible\ from\ the\ src\ buffer.\r\n
comment11.params=src
comment11.target=int\ doWrite(java.nio.ByteBuffer)
comment11.text=\r\n\ Try\ to\ flush\ out\ any\ existing\ outbound\ data,\ then\ try\ to\ wrap\r\n\ anything\ new\ contained\ in\ the\ src\ buffer.\r\n\ <P>\r\n\ Return\ the\ number\ of\ bytes\ actually\ consumed\ from\ the\ buffer,\r\n\ but\ the\ data\ may\ actually\ be\ still\ sitting\ in\ the\ output\ buffer,\r\n\ waiting\ to\ be\ flushed.\r\n
comment12.params=fc\ pos\ len
comment12.target=long\ transferTo(java.nio.channels.FileChannel,\ long,\ long)
comment12.text=\r\n\ Perform\ a\ FileChannel.TransferTo\ on\ the\ socket\ channel.\r\n\ <P>\r\n\ We\ have\ to\ copy\ the\ data\ into\ an\ intermediary\ app\ ByteBuffer\r\n\ first,\ then\ send\ it\ through\ the\ SSLEngine.\r\n\ <P>\r\n\ We\ return\ the\ number\ of\ bytes\ actually\ read\ out\ of\ the\r\n\ filechannel.\ \ However,\ the\ data\ may\ actually\ be\ stuck\r\n\ in\ the\ fileChannelBB\ or\ the\ outNetBB.\ \ The\ caller\r\n\ is\ responsible\ for\ making\ sure\ to\ call\ dataFlush()\r\n\ before\ shutting\ down.\r\n
comment13.params=
comment13.target=boolean\ dataFlush()
comment13.text=\r\n\ Flush\ any\ remaining\ data.\r\n\ <P>\r\n\ Return\ true\ when\ the\ fileChannelBB\ and\ outNetBB\ are\ empty.\r\n
comment14.params=
comment14.target=boolean\ shutdown()
comment14.text=\r\n\ Begin\ the\ shutdown\ process.\r\n\ <P>\r\n\ Close\ out\ the\ SSLEngine\ if\ not\ already\ done\ so,\ then\r\n\ wrap\ our\ outgoing\ close_notify\ message\ and\ try\ to\ send\ it\ on.\r\n\ <P>\r\n\ Return\ true\ when\ we're\ done\ passing\ the\ shutdown\ messsages.\r\n
comment2.params=sc\ blocking\ sslc
comment2.target=ChannelIOSecure\ getInstance(java.nio.channels.SocketChannel,\ boolean,\ javax.net.ssl.SSLContext)
comment2.text=\r\n\ Static\ factory\ method\ for\ creating\ a\ secure\ ChannelIO\ object.\r\n\ <P>\r\n\ We\ need\ to\ allocate\ different\ sized\ application\ data\ buffers\r\n\ based\ on\ whether\ we're\ secure\ or\ not.\ \ We\ can't\ determine\r\n\ this\ until\ our\ sslEngine\ is\ created.\r\n
comment3.params=
comment3.target=void\ resizeRequestBB()
comment3.text=\r\n\ Calls\ up\ to\ the\ superclass\ to\ adjust\ the\ buffer\ size\r\n\ by\ an\ appropriate\ increment.\r\n
comment4.params=
comment4.target=void\ resizeResponseBB()
comment4.text=\r\n\ Adjust\ the\ inbount\ network\ buffer\ to\ an\ appropriate\ size.\r\n
comment5.params=bb
comment5.target=boolean\ tryFlush(java.nio.ByteBuffer)
comment5.text=\r\n\ Writes\ bb\ to\ the\ SocketChannel.\r\n\ <P>\r\n\ Returns\ true\ when\ the\ ByteBuffer\ has\ no\ remaining\ data.\r\n
comment6.params=
comment6.target=boolean\ doHandshake()
comment6.text=\r\n\ Perform\ any\ handshaking\ processing.\r\n\ <P>\r\n\ This\ variant\ is\ for\ Servers\ without\ SelectionKeys\ (e.g.\r\n\ blocking).\r\n
comment7.params=sk
comment7.target=boolean\ doHandshake(java.nio.channels.SelectionKey)
comment7.text=\r\n\ Perform\ any\ handshaking\ processing.\r\n\ <P>\r\n\ If\ a\ SelectionKey\ is\ passed,\ register\ for\ selectable\r\n\ operations.\r\n\ <P>\r\n\ In\ the\ blocking\ case,\ our\ caller\ will\ keep\ calling\ us\ until\r\n\ we\ finish\ the\ handshake.\ \ Our\ reads/writes\ will\ block\ as\ expected.\r\n\ <P>\r\n\ In\ the\ non-blocking\ case,\ we\ just\ received\ the\ selection\ notification\r\n\ that\ this\ channel\ is\ ready\ for\ whatever\ the\ operation\ is,\ so\ give\r\n\ it\ a\ try.\r\n\ <P>\r\n\ return\:\r\n\ \ \ \ \ \ \ \ \ \ true\ when\ handshake\ is\ done.\r\n\ \ \ \ \ \ \ \ \ \ false\ while\ handshake\ is\ in\ progress\r\n
comment8.params=
comment8.target=javax.net.ssl.SSLEngineResult.HandshakeStatus\ doTasks()
comment8.text=\r\n\ Do\ all\ the\ outstanding\ handshake\ tasks\ in\ the\ current\ Thread.\r\n
comment9.params=
comment9.target=int\ read()
comment9.text=\r\n\ Read\ the\ channel\ for\ more\ information,\ then\ unwrap\ the\r\n\ (hopefully\ application)\ data\ we\ get.\r\n\ <P>\r\n\ If\ we\ run\ out\ of\ data,\ we'll\ return\ to\ our\ caller\ (possibly\ using\r\n\ a\ Selector)\ to\ get\ notification\ that\ more\ is\ available.\r\n\ <P>\r\n\ Each\ call\ to\ this\ method\ will\ perform\ at\ most\ one\ underlying\ read().\r\n
numComments=15
